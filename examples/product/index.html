<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SMNTC — Product Showcase</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;500;700&display=swap" rel="stylesheet" />
  <style>
    /* ====================================================================
       RESET & BASE
       ==================================================================== */
    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
    html { scroll-behavior: smooth; }
    body {
      background: #050510;
      color: #e9eefc;
      font-family: 'Outfit', -apple-system, BlinkMacSystemFont, sans-serif;
      overflow-x: hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      min-height: 100vh;
    }

    /* ====================================================================
       CSS VARIABLES
       ==================================================================== */
    :root {
      --accent-primary: #e0e0e0;
      --accent-secondary: #ffffff;
      --accent-primary-rgb: 224, 224, 224;
    }

    /* ====================================================================
       CANVAS
       ==================================================================== */
    #scene {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      z-index: 0;
    }

    /* ====================================================================
       CONTENT OVERLAY
       ==================================================================== */
    .content {
      position: relative;
      z-index: 2;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 60px 24px 80px;
      pointer-events: none;
      min-height: 100vh;
    }
    .content > * { pointer-events: auto; }

    /* ====================================================================
       GLASSMORPHISM BASE
       ==================================================================== */
    .glass {
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(24px);
      -webkit-backdrop-filter: blur(24px);
      border-radius: 24px;
    }

    /* ====================================================================
       PRODUCT CARD
       ==================================================================== */
    .product-card {
      max-width: 540px;
      width: 100%;
      padding: 36px;
      margin-bottom: 48px;
      opacity: 0;
      transform: translateY(24px);
      animation: fadeUp 0.9s cubic-bezier(0.22, 1, 0.36, 1) 0.3s forwards;
    }

    /* Product image placeholder */
    .product-image {
      width: 100%;
      height: 260px;
      border-radius: 16px;
      background: linear-gradient(135deg,
        rgba(var(--accent-primary-rgb), 0.15) 0%,
        rgba(var(--accent-primary-rgb), 0.05) 50%,
        rgba(var(--accent-primary-rgb), 0.2) 100%
      );
      border: 1px solid rgba(var(--accent-primary-rgb), 0.12);
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 28px;
      position: relative;
      overflow: hidden;
    }
    .product-image::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg,
        transparent 30%,
        rgba(var(--accent-primary-rgb), 0.08) 50%,
        transparent 70%
      );
      animation: shimmer 3s ease-in-out infinite;
    }
    .product-image-text {
      font-family: 'Outfit', sans-serif;
      font-size: 2.4rem;
      font-weight: 700;
      letter-spacing: 0.15em;
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      opacity: 0.7;
      position: relative;
      z-index: 1;
    }

    /* Product name */
    .product-name {
      font-size: 2rem;
      font-weight: 700;
      letter-spacing: -0.02em;
      color: #fff;
      margin-bottom: 12px;
    }

    /* Rating */
    .product-rating {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 16px;
    }
    .star {
      width: 18px;
      height: 18px;
      fill: var(--accent-primary);
      opacity: 0.9;
    }
    .rating-count {
      font-size: 0.85rem;
      font-weight: 300;
      color: rgba(233, 238, 252, 0.45);
      margin-left: 6px;
    }

    /* Price */
    .product-price {
      display: flex;
      align-items: baseline;
      gap: 12px;
      margin-bottom: 16px;
    }
    .price-current {
      font-size: 2rem;
      font-weight: 700;
      color: var(--accent-primary);
    }
    .price-original {
      font-size: 1.1rem;
      font-weight: 300;
      color: rgba(233, 238, 252, 0.3);
      text-decoration: line-through;
    }

    /* Description */
    .product-desc {
      font-size: 0.95rem;
      font-weight: 300;
      line-height: 1.7;
      color: rgba(233, 238, 252, 0.55);
      margin-bottom: 24px;
    }

    /* Color variants */
    .color-variants {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 28px;
    }
    .color-variants-label {
      font-size: 0.75rem;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: rgba(233, 238, 252, 0.35);
      margin-right: 4px;
    }
    .color-dot {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid transparent;
      transition: all 0.35s cubic-bezier(0.22, 1, 0.36, 1);
      position: relative;
    }
    .color-dot:hover {
      transform: scale(1.15);
    }
    .color-dot.active {
      border-color: var(--accent-primary);
      box-shadow: 0 0 12px rgba(var(--accent-primary-rgb), 0.35);
    }
    .color-dot::after {
      content: '';
      position: absolute;
      inset: 3px;
      border-radius: 50%;
      background: inherit;
    }

    /* Add to Cart button */
    .btn-cart {
      width: 100%;
      padding: 16px 32px;
      border: none;
      border-radius: 14px;
      font-family: 'Outfit', sans-serif;
      font-size: 1rem;
      font-weight: 700;
      letter-spacing: 0.04em;
      cursor: pointer;
      background: var(--accent-primary);
      color: #050510;
      transition: all 0.35s cubic-bezier(0.22, 1, 0.36, 1);
      position: relative;
      overflow: hidden;
    }
    .btn-cart::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, transparent 40%, rgba(255,255,255,0.2) 50%, transparent 60%);
      transform: translateX(-100%);
      transition: transform 0.5s ease;
    }
    .btn-cart:hover {
      transform: translateY(-2px);
      box-shadow:
        0 0 30px rgba(var(--accent-primary-rgb), 0.3),
        0 8px 32px rgba(0, 0, 0, 0.3);
    }
    .btn-cart:hover::before {
      transform: translateX(100%);
    }
    .btn-cart:active {
      transform: translateY(0);
    }

    /* ====================================================================
       PALETTE SHOWCASE STRIP
       ==================================================================== */
    .palette-strip-wrapper {
      width: 100%;
      max-width: 900px;
      margin-bottom: 48px;
      opacity: 0;
      transform: translateY(24px);
      animation: fadeUp 0.9s cubic-bezier(0.22, 1, 0.36, 1) 0.6s forwards;
    }
    .palette-strip-title {
      font-size: 0.7rem;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.15em;
      color: rgba(233, 238, 252, 0.3);
      margin-bottom: 14px;
      text-align: center;
    }
    .palette-strip {
      display: flex;
      gap: 10px;
      overflow-x: auto;
      padding: 8px 4px 16px;
      scroll-snap-type: x mandatory;
      -ms-overflow-style: none;
      scrollbar-width: none;
    }
    .palette-strip::-webkit-scrollbar { display: none; }

    .palette-card {
      flex: 0 0 auto;
      width: 120px;
      padding: 14px 12px;
      border-radius: 14px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.06);
      cursor: pointer;
      transition: all 0.35s cubic-bezier(0.22, 1, 0.36, 1);
      scroll-snap-align: start;
      user-select: none;
      -webkit-user-select: none;
    }
    .palette-card:hover {
      background: rgba(255, 255, 255, 0.06);
      border-color: rgba(255, 255, 255, 0.12);
      transform: translateY(-3px);
    }
    .palette-card.active {
      border-color: var(--accent-primary);
      background: rgba(var(--accent-primary-rgb), 0.08);
      box-shadow: 0 0 16px rgba(var(--accent-primary-rgb), 0.15);
    }
    .palette-card-name {
      font-size: 0.7rem;
      font-weight: 500;
      color: rgba(233, 238, 252, 0.7);
      margin-bottom: 8px;
      text-transform: capitalize;
    }
    .palette-card-gradient {
      height: 28px;
      border-radius: 8px;
      margin-bottom: 8px;
    }
    .palette-card-hex {
      font-size: 0.58rem;
      font-weight: 300;
      color: rgba(233, 238, 252, 0.35);
      line-height: 1.4;
      font-variant-numeric: tabular-nums;
    }

    /* ====================================================================
       FEATURE HIGHLIGHTS
       ==================================================================== */
    .features {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 20px;
      max-width: 900px;
      width: 100%;
      opacity: 0;
      transform: translateY(24px);
      animation: fadeUp 0.9s cubic-bezier(0.22, 1, 0.36, 1) 0.9s forwards;
    }
    .feature-card {
      padding: 28px 24px;
      text-align: center;
      transition: all 0.35s cubic-bezier(0.22, 1, 0.36, 1);
    }
    .feature-card:hover {
      border-color: rgba(var(--accent-primary-rgb), 0.2);
      background: rgba(var(--accent-primary-rgb), 0.04);
      transform: translateY(-4px);
    }
    .feature-icon {
      width: 48px;
      height: 48px;
      margin: 0 auto 16px;
      border-radius: 14px;
      background: rgba(var(--accent-primary-rgb), 0.08);
      border: 1px solid rgba(var(--accent-primary-rgb), 0.12);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .feature-icon svg {
      width: 22px;
      height: 22px;
      stroke: var(--accent-primary);
      fill: none;
      stroke-width: 1.5;
      stroke-linecap: round;
      stroke-linejoin: round;
    }
    .feature-title {
      font-size: 1.1rem;
      font-weight: 700;
      color: #fff;
      margin-bottom: 8px;
    }
    .feature-desc {
      font-size: 0.82rem;
      font-weight: 300;
      line-height: 1.6;
      color: rgba(233, 238, 252, 0.45);
    }

    /* ====================================================================
       ANIMATIONS
       ==================================================================== */
    @keyframes fadeUp {
      from { opacity: 0; transform: translateY(24px); }
      to   { opacity: 1; transform: translateY(0); }
    }
    @keyframes shimmer {
      0%, 100% { opacity: 0; }
      50% { opacity: 1; }
    }

    /* ====================================================================
       RESPONSIVE
       ==================================================================== */
    @media (max-width: 768px) {
      .content { padding: 40px 16px 60px; }
      .product-card { padding: 24px; }
      .product-image { height: 200px; }
      .product-name { font-size: 1.6rem; }
      .features {
        grid-template-columns: 1fr;
        gap: 14px;
        max-width: 540px;
      }
      .feature-card { padding: 22px 20px; }
      .palette-card { width: 105px; padding: 12px 10px; }
    }
    @media (max-width: 480px) {
      .product-name { font-size: 1.35rem; }
      .price-current { font-size: 1.6rem; }
      .product-image { height: 160px; }
      .product-image-text { font-size: 1.6rem; }
    }
  </style>
</head>
<body>
  <!-- WebGL Canvas -->
  <canvas id="scene"></canvas>

  <!-- Content Overlay -->
  <div class="content">

    <!-- Product Card -->
    <div class="product-card glass">
      <div class="product-image">
        <span class="product-image-text">SMNTC</span>
      </div>
      <h1 class="product-name">Flux Studio Pro</h1>
      <div class="product-rating">
        <svg class="star" viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87L18.18 22 12 18.56 5.82 22 7 14.14l-5-4.87 6.91-1.01L12 2z"/></svg>
        <svg class="star" viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87L18.18 22 12 18.56 5.82 22 7 14.14l-5-4.87 6.91-1.01L12 2z"/></svg>
        <svg class="star" viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87L18.18 22 12 18.56 5.82 22 7 14.14l-5-4.87 6.91-1.01L12 2z"/></svg>
        <svg class="star" viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87L18.18 22 12 18.56 5.82 22 7 14.14l-5-4.87 6.91-1.01L12 2z"/></svg>
        <svg class="star" viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87L18.18 22 12 18.56 5.82 22 7 14.14l-5-4.87 6.91-1.01L12 2z"/></svg>
        <span class="rating-count">(2,847 reviews)</span>
      </div>
      <div class="product-price">
        <span class="price-current">$299</span>
        <span class="price-original">$499</span>
      </div>
      <p class="product-desc">
        The ultimate semantic shader toolkit. Map natural-language tokens to GPU-driven visual effects — 
        13 color palettes, 8 surface topologies, 9 kinetic vibes, and cinema-grade VFX. 
        All running at 60 fps with spring-animated transitions.
      </p>
      <div class="color-variants">
        <span class="color-variants-label">Color</span>
        <div class="color-dot active" data-palette="monochrome" style="background:#e0e0e0" title="Monochrome"></div>
        <div class="color-dot" data-palette="ember" style="background:#ff6b35" title="Ember"></div>
        <div class="color-dot" data-palette="arctic" style="background:#88ccff" title="Arctic"></div>
        <div class="color-dot" data-palette="neon" style="background:#00ff88" title="Neon"></div>
        <div class="color-dot" data-palette="ocean" style="background:#0077b6" title="Ocean"></div>
        <div class="color-dot" data-palette="sunset" style="background:#f77f00" title="Sunset"></div>
        <div class="color-dot" data-palette="vapor" style="background:#ff71ce" title="Vapor"></div>
        <div class="color-dot" data-palette="gold" style="background:#ffd700" title="Gold"></div>
        <div class="color-dot" data-palette="aurora" style="background:#43b581" title="Aurora"></div>
      </div>
      <button class="btn-cart">Add to Cart</button>
    </div>

    <!-- Palette Showcase Strip -->
    <div class="palette-strip-wrapper">
      <div class="palette-strip-title">13 Handcrafted Palettes</div>
      <div class="palette-strip" id="paletteStrip"></div>
    </div>

    <!-- Feature Highlights -->
    <div class="features">
      <div class="feature-card glass">
        <div class="feature-icon">
          <svg viewBox="0 0 24 24"><path d="M12 2L2 7l10 5 10-5-10-5z"/><path d="M2 17l10 5 10-5"/><path d="M2 12l10 5 10-5"/></svg>
        </div>
        <div class="feature-title">8 Surfaces</div>
        <p class="feature-desc">Topographic, crystalline, fluid, glitch, organic, terrain, plasma, and wave — each with unique displacement algorithms.</p>
      </div>
      <div class="feature-card glass">
        <div class="feature-icon">
          <svg viewBox="0 0 24 24"><path d="M2 12c0-5.5 4.5-10 10-10s10 4.5 10 10"/><circle cx="12" cy="12" r="3"/><path d="M12 2v4"/><path d="M12 18v4"/><path d="M4.93 4.93l2.83 2.83"/><path d="M16.24 16.24l2.83 2.83"/></svg>
        </div>
        <div class="feature-title">9 Vibes</div>
        <p class="feature-desc">From meditative breathing to chaotic storm — spring-physics motion presets that feel alive and responsive.</p>
      </div>
      <div class="feature-card glass">
        <div class="feature-icon">
          <svg viewBox="0 0 24 24"><path d="M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .2 2.2 1.5 3.5.7.7 1.3 1.5 1.5 2.5"/><path d="M9 18h6"/><path d="M10 22h4"/></svg>
        </div>
        <div class="feature-title">Cinema-Grade VFX</div>
        <p class="feature-desc">Film grain, bloom glow, chromatic aberration, vignette, and depth blur — all GPU-accelerated in real time.</p>
      </div>
    </div>
  </div>

  <!-- ================================================================== -->
  <!-- THREE.JS + INLINE SMNTC SHADER ENGINE                              -->
  <!-- ================================================================== -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';

    // ====================================================================
    // PALETTE DEFINITIONS (normalized RGB) — all 13
    // ====================================================================
    const PALETTES = {
      monochrome: { primary: [0.878,0.878,0.878], accent: [1,1,1],             bg: [0,0,0],             hex: ['#e0e0e0','#ffffff'] },
      ember:      { primary: [1,0.42,0.21],       accent: [1,0.67,0],           bg: [0.04,0.04,0.04],    hex: ['#ff6b35','#ffaa00'] },
      arctic:     { primary: [0.533,0.8,1],        accent: [1,1,1],             bg: [0.02,0.02,0.063],   hex: ['#88ccff','#ffffff'] },
      neon:       { primary: [0,1,0.533],          accent: [1,0,1],             bg: [0.04,0.04,0.04],    hex: ['#00ff88','#ff00ff'] },
      phantom:    { primary: [0.627,0.627,0.69],   accent: [0.376,0.376,0.627], bg: [0.031,0.031,0.047], hex: ['#a0a0b0','#6060a0'] },
      ocean:      { primary: [0,0.467,0.714],      accent: [0,0.706,0.847],     bg: [0.012,0.027,0.118], hex: ['#0077b6','#00b4d8'] },
      sunset:     { primary: [0.969,0.498,0],       accent: [0.839,0.157,0.157], bg: [0.051,0.008,0.031], hex: ['#f77f00','#d62828'] },
      matrix:     { primary: [0,1,0.255],          accent: [0,0.561,0.067],     bg: [0,0,0],             hex: ['#00ff41','#008f11'] },
      vapor:      { primary: [1,0.443,0.808],      accent: [0.004,0.804,0.996], bg: [0.039,0,0.071],     hex: ['#ff71ce','#01cdfe'] },
      gold:       { primary: [1,0.843,0],          accent: [0.855,0.647,0.125], bg: [0.039,0.031,0],     hex: ['#ffd700','#daa520'] },
      infrared:   { primary: [1,0,0.333],          accent: [1,0.4,0],           bg: [0.039,0,0.02],      hex: ['#ff0055','#ff6600'] },
      aurora:     { primary: [0.263,0.710,0.506],  accent: [0.447,0.537,0.855], bg: [0.008,0.031,0.063], hex: ['#43b581','#7289da'] },
      midnight:   { primary: [0.753,0.753,0.784],  accent: [0.29,0.435,0.647],  bg: [0.039,0.055,0.102], hex: ['#c0c0c8','#4a6fa5'] },
    };

    // ====================================================================
    // SURFACE DEFINITIONS — all 8
    // ====================================================================
    const SURFACES = {
      topographic: { mode: 0, noiseScale: 1.0 },
      crystalline: { mode: 1, noiseScale: 2.5 },
      fluid:       { mode: 2, noiseScale: 0.6 },
      glitch:      { mode: 3, noiseScale: 3.0 },
      organic:     { mode: 4, noiseScale: 0.8 },
      terrain:     { mode: 5, noiseScale: 1.5 },
      plasma:      { mode: 6, noiseScale: 2.0 },
      wave:        { mode: 7, noiseScale: 0.5 },
    };

    // ====================================================================
    // VIBE DEFINITIONS — all 9
    // ====================================================================
    const VIBES = {
      stable:    { frequency: 0.1,  amplitude: 0.02, noiseSpeed: 0.05 },
      calm:      { frequency: 0.5,  amplitude: 0.08, noiseSpeed: 0.15 },
      agitated:  { frequency: 2.5,  amplitude: 0.20, noiseSpeed: 0.60 },
      chaotic:   { frequency: 5.0,  amplitude: 0.40, noiseSpeed: 1.50 },
      breathing: { frequency: 0.08, amplitude: 0.05, noiseSpeed: 0.03 },
      pulse:     { frequency: 1.2,  amplitude: 0.15, noiseSpeed: 0.30 },
      drift:     { frequency: 0.3,  amplitude: 0.06, noiseSpeed: 0.10 },
      storm:     { frequency: 4.0,  amplitude: 0.35, noiseSpeed: 1.20 },
      cinematic: { frequency: 0.2,  amplitude: 0.12, noiseSpeed: 0.08 },
    };

    // ====================================================================
    // SPRING PHYSICS (damped harmonic oscillator: F = -kx - cv)
    // ====================================================================
    class Spring {
      constructor(value, stiffness = 80, damping = 12) {
        this.value = value;
        this.target = value;
        this.velocity = 0;
        this.stiffness = stiffness;
        this.damping = damping;
      }
      set(target) { this.target = target; }
      snap(value) { this.value = value; this.target = value; this.velocity = 0; }
      tick(dt) {
        const dx = this.target - this.value;
        const springForce = dx * this.stiffness;
        const dampForce = -this.velocity * this.damping;
        this.velocity += (springForce + dampForce) * dt;
        this.value += this.velocity * dt;
        return this.value;
      }
      get settled() {
        return Math.abs(this.velocity) < 0.001 && Math.abs(this.value - this.target) < 0.001;
      }
    }

    // ====================================================================
    // STATE — initial: surface=fluid, vibe=calm, palette=monochrome
    // ====================================================================
    let currentPalette = 'monochrome';

    const springs = {
      frequency:   new Spring(VIBES.calm.frequency),
      amplitude:   new Spring(VIBES.calm.amplitude),
      noiseScale:  new Spring(SURFACES.fluid.noiseScale),
      noiseSpeed:  new Spring(VIBES.calm.noiseSpeed),
      surfaceMode: new Spring(SURFACES.fluid.mode, 120, 14),
      primaryR:    new Spring(PALETTES.monochrome.primary[0]),
      primaryG:    new Spring(PALETTES.monochrome.primary[1]),
      primaryB:    new Spring(PALETTES.monochrome.primary[2]),
      accentR:     new Spring(PALETTES.monochrome.accent[0]),
      accentG:     new Spring(PALETTES.monochrome.accent[1]),
      accentB:     new Spring(PALETTES.monochrome.accent[2]),
      bgR:         new Spring(PALETTES.monochrome.bg[0]),
      bgG:         new Spring(PALETTES.monochrome.bg[1]),
      bgB:         new Spring(PALETTES.monochrome.bg[2]),
      grain:       new Spring(0),
      glow:        new Spring(0.3),
      chromatic:   new Spring(0),
      vignette:    new Spring(0),
      blur:        new Spring(0),
      speed:       new Spring(1.0),
      intensity:   new Spring(1.0),
      angle:       new Spring(0),
      pointerX:    new Spring(0, 60, 10),
      pointerY:    new Spring(0, 60, 10),
    };

    // ====================================================================
    // VERTEX SHADER — all 8 surfaces, reactivity, angle rotation
    // ====================================================================
    const vertexShader = /* glsl */ `
precision highp float;

uniform float uTime;
uniform float uSurfaceMode;
uniform float uFrequency;
uniform float uAmplitude;
uniform float uNoiseScale;
uniform float uNoiseSpeed;
uniform float uIntensity;
uniform float uSpeed;
uniform float uContourLines;
uniform float uReactivityMode;
uniform float uReactivityStrength;
uniform float uReactivityRadius;
uniform vec3  uPointer;
uniform float uShockTime;
uniform float uAngle;

varying vec3  vNormal;
varying vec3  vPosition;
varying float vDisplacement;
varying vec2  vUv;

// ---- Simplex 3D Noise ----
vec3 mod289(vec3 x) { return x - floor(x*(1.0/289.0))*289.0; }
vec4 mod289(vec4 x) { return x - floor(x*(1.0/289.0))*289.0; }
vec4 permute(vec4 x) { return mod289(((x*34.0)+10.0)*x); }
vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314*r; }

float snoise(vec3 v) {
  const vec2 C = vec2(1.0/6.0, 1.0/3.0);
  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
  vec3 i = floor(v + dot(v, C.yyy));
  vec3 x0 = v - i + dot(i, C.xxx);
  vec3 g = step(x0.yzx, x0.xyz);
  vec3 l = 1.0 - g;
  vec3 i1 = min(g.xyz, l.zxy);
  vec3 i2 = max(g.xyz, l.zxy);
  vec3 x1 = x0 - i1 + C.xxx;
  vec3 x2 = x0 - i2 + C.yyy;
  vec3 x3 = x0 - D.yyy;
  i = mod289(i);
  vec4 p = permute(permute(permute(
    i.z + vec4(0.0, i1.z, i2.z, 1.0))
  + i.y + vec4(0.0, i1.y, i2.y, 1.0))
  + i.x + vec4(0.0, i1.x, i2.x, 1.0));
  float n_ = 0.142857142857;
  vec3 ns = n_ * D.wyz - D.xzx;
  vec4 j = p - 49.0*floor(p*ns.z*ns.z);
  vec4 x_ = floor(j*ns.z);
  vec4 y_ = floor(j - 7.0*x_);
  vec4 x = x_*ns.x + ns.yyyy;
  vec4 y = y_*ns.x + ns.yyyy;
  vec4 h = 1.0 - abs(x) - abs(y);
  vec4 b0 = vec4(x.xy, y.xy);
  vec4 b1 = vec4(x.zw, y.zw);
  vec4 s0 = floor(b0)*2.0 + 1.0;
  vec4 s1 = floor(b1)*2.0 + 1.0;
  vec4 sh = -step(h, vec4(0.0));
  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
  vec3 p0 = vec3(a0.xy, h.x);
  vec3 p1 = vec3(a0.zw, h.y);
  vec3 p2 = vec3(a1.xy, h.z);
  vec3 p3 = vec3(a1.zw, h.w);
  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
  p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
  vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
  m = m*m;
  return 105.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
}

// ---- Voronoi ----
float voronoi(vec3 p) {
  vec3 i_st = floor(p); vec3 f_st = fract(p);
  float md = 1.0;
  for (int z=-1; z<=1; z++) for (int y=-1; y<=1; y++) for (int x=-1; x<=1; x++) {
    vec3 nb = vec3(float(x), float(y), float(z));
    vec3 pt = vec3(
      fract(sin(dot(i_st+nb, vec3(12.9898,78.233,45.164)))*43758.5453),
      fract(sin(dot(i_st+nb, vec3(93.989,67.345,12.456)))*28461.2534),
      fract(sin(dot(i_st+nb, vec3(43.332,93.532,65.123)))*63728.1927)
    );
    md = min(md, length(nb + pt - f_st));
  }
  return md;
}

// ---- 8 Surface Displacement Functions ----
float topographicDisp(vec3 p, float t) {
  float w1 = sin(p.x*uFrequency+t*0.8)*0.5;
  float w2 = sin(p.y*uFrequency*1.3+t*0.6)*0.3;
  float w3 = cos(p.x*uFrequency*0.7+p.y*uFrequency*0.9+t*1.1)*0.2;
  return (w1+w2+w3)*uAmplitude*uIntensity;
}
float crystallineDisp(vec3 p, float t) {
  float v = voronoi(p*uNoiseScale+vec3(0.0,0.0,t*uNoiseSpeed));
  return floor(v*8.0)/8.0*uAmplitude*uIntensity;
}
float fluidDisp(vec3 p, float t) {
  float n1 = snoise(p*uNoiseScale+vec3(0.0,0.0,t*uNoiseSpeed));
  float n2 = snoise(p*uNoiseScale*2.0+vec3(t*uNoiseSpeed*0.5));
  return (n1*0.6+n2*0.4)*uAmplitude*uIntensity;
}
float glitchDisp(vec3 p, float t) {
  float base = snoise(p*uNoiseScale+vec3(0.0,0.0,t*uNoiseSpeed));
  float q = floor(base*4.0+0.5)/4.0;
  float burst = step(0.92, fract(sin(dot(p.xy+t, vec2(12.9898,78.233)))*43758.5453));
  return (q+burst*0.3)*uAmplitude*uIntensity;
}
float organicDisp(vec3 p, float t) {
  float w1 = snoise(p*uNoiseScale*0.5+vec3(t*uNoiseSpeed*0.3));
  float w2 = snoise(p*uNoiseScale*0.5+vec3(0.0,t*uNoiseSpeed*0.4,0.0));
  vec3 wp = p+vec3(w1,w2,0.0)*0.5;
  float n = snoise(wp*uNoiseScale+vec3(0.0,0.0,t*uNoiseSpeed));
  float n2 = snoise(wp*uNoiseScale*1.5+vec3(t*uNoiseSpeed*0.7));
  return (n*0.7+n2*0.3)*uAmplitude*uIntensity;
}
float terrainDisp(vec3 p, float t) {
  float total=0.0, amp=1.0, freq=1.0, weight=1.0;
  for (int i=0; i<5; i++) {
    float n = abs(snoise(p*uNoiseScale*freq+vec3(0.0,0.0,t*uNoiseSpeed*0.2)));
    n = 1.0-n; n *= n; n *= weight;
    weight = clamp(n*2.0, 0.0, 1.0);
    total += n*amp; freq *= 2.1; amp *= 0.5;
  }
  return total*uAmplitude*uIntensity*0.5;
}
float plasmaDisp(vec3 p, float t) {
  float n1 = sin(p.x*uNoiseScale*1.5+t*uNoiseSpeed*2.0);
  float n2 = sin(p.y*uNoiseScale*1.5+t*uNoiseSpeed*1.5);
  float n3 = snoise(p*uNoiseScale+vec3(t*uNoiseSpeed));
  float n4 = sin((p.x+p.y)*uNoiseScale+t*uNoiseSpeed*3.0)*0.5;
  return (n1+n2+n3+n4)*0.25*uAmplitude*uIntensity;
}
float waveDisp(vec3 p, float t) {
  float w = 0.0;
  w += sin(p.x*uFrequency*2.0+t*1.5)*0.4;
  w += sin(p.x*uFrequency*0.8-p.y*uFrequency*0.5+t*1.2)*0.3;
  w += sin(p.y*uFrequency*1.5+t*0.9)*0.2;
  w += sin((p.x+p.y)*uFrequency*0.6+t*2.0)*0.1;
  w += snoise(p*uNoiseScale*0.5+vec3(0.0,0.0,t*uNoiseSpeed*0.5))*0.15;
  return w*uAmplitude*uIntensity;
}

float getDisplacement(vec3 pos, float t) {
  float ca = cos(uAngle), sa = sin(uAngle);
  vec3 rp = vec3(pos.x*ca - pos.y*sa, pos.x*sa + pos.y*ca, pos.z);
  if (uSurfaceMode < 0.5) return topographicDisp(rp, t);
  if (uSurfaceMode < 1.5) return crystallineDisp(rp, t);
  if (uSurfaceMode < 2.5) return fluidDisp(rp, t);
  if (uSurfaceMode < 3.5) return glitchDisp(rp, t);
  if (uSurfaceMode < 4.5) return organicDisp(rp, t);
  if (uSurfaceMode < 5.5) return terrainDisp(rp, t);
  if (uSurfaceMode < 6.5) return plasmaDisp(rp, t);
  return waveDisp(rp, t);
}

// ---- Reactivity ----
float reactivityOffset(vec3 wp) {
  if (uReactivityMode < 0.5) return 0.0;
  float dist = distance(wp, uPointer);
  float influence = 1.0 - smoothstep(0.0, uReactivityRadius, dist);
  if (uReactivityMode < 1.5) return  influence * uReactivityStrength * 0.3;
  if (uReactivityMode < 2.5) return -influence * uReactivityStrength * 0.3;
  float sr = uShockTime*3.0;
  float sw = sin((dist-sr)*10.0)*exp(-uShockTime*2.0);
  float si = smoothstep(sr+1.0,sr,dist)*smoothstep(sr-1.0,sr,dist);
  return sw*si*uReactivityStrength*0.5;
}

// ---- Finite-Difference Normal ----
vec3 computeNormal(vec3 pos, vec3 norm, float t) {
  float eps = 0.01;
  float dX = getDisplacement(pos+vec3(eps,0,0),t) - getDisplacement(pos-vec3(eps,0,0),t);
  float dZ = getDisplacement(pos+vec3(0,0,eps),t) - getDisplacement(pos-vec3(0,0,eps),t);
  return normalize(norm + vec3(-dX/(2.0*eps), 1.0, -dZ/(2.0*eps)));
}

void main() {
  float t = mod(uTime * uSpeed, 6283.1853);
  vec3 pos = position;
  float disp = getDisplacement(pos, t) + reactivityOffset(pos);
  vec3 displaced = pos + normal * disp;
  vNormal = normalize(normalMatrix * computeNormal(pos, normal, t));
  vPosition = (modelViewMatrix * vec4(displaced, 1.0)).xyz;
  vDisplacement = disp;
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(displaced, 1.0);
}
`;

    // ====================================================================
    // FRAGMENT SHADER — wireframe, lighting, all VFX
    // ====================================================================
    const fragmentShader = /* glsl */ `
precision highp float;

uniform vec3  uPrimaryColor;
uniform vec3  uAccentColor;
uniform vec3  uBackgroundColor;
uniform float uContourLines;
uniform float uSurfaceMode;
uniform float uWireframe;
uniform float uWireframeWidth;
uniform float uIntensity;
uniform float uTime;
uniform float uGrain;
uniform float uGlow;
uniform float uChromatic;
uniform float uVignette;
uniform float uBlur;

varying vec3  vNormal;
varying vec3  vPosition;
varying float vDisplacement;
varying vec2  vUv;

// Wireframe edge
float edgeFactor() {
  vec2 grid = abs(fract(vUv*uContourLines - 0.5) - 0.5);
  vec2 dG = fwidth(vUv*uContourLines);
  vec2 a2 = smoothstep(vec2(0.0), dG*uWireframeWidth*1.5, grid);
  return min(a2.x, a2.y);
}

// Displacement contour lines
float contourFactor() {
  float sd = vDisplacement*uContourLines*10.0;
  float line = abs(fract(sd)-0.5);
  return smoothstep(0.0, fwidth(sd)*1.5, line);
}

// Enhanced Phong lighting
vec3 lighting(vec3 bc) {
  vec3 ld = normalize(vec3(0.5,1.0,0.8));
  vec3 vd = normalize(-vPosition);
  vec3 n = normalize(vNormal);
  float ambient = 0.15;
  float diff = max(dot(n, ld), 0.0);
  vec3 hd = normalize(ld+vd);
  float spec = pow(max(dot(n,hd),0.0), 64.0)*0.3;
  float rim = pow(1.0-max(dot(vd,n),0.0), 3.0)*0.2;
  vec3 fd = normalize(vec3(-0.3,0.5,-0.6));
  float fill = max(dot(n,fd),0.0)*0.15;
  return bc*(ambient+diff*0.7+fill)+vec3(spec+rim);
}

// Film grain
float filmGrain(vec2 uv, float t) {
  float n1 = fract(sin(dot(uv*1000.0+t*100.0, vec2(12.9898,78.233)))*43758.5453);
  float n2 = fract(sin(dot(uv*800.0-t*50.0, vec2(63.7264,10.873)))*28462.6453);
  return (n1*0.5+n2*0.5)*2.0-1.0;
}

// Vignette
float vignetteEffect(vec2 uv) {
  vec2 c = uv-0.5;
  return 1.0-smoothstep(0.3, 0.85, length(c));
}

void main() {
  float bf = smoothstep(-0.15,0.15,vDisplacement)*uIntensity;
  vec3 baseColor = mix(uPrimaryColor, uAccentColor, bf);
  vec4 fc;

  if (uWireframe > 0.5) {
    float contour = contourFactor();
    float edge = edgeFactor();
    float lf = min(contour, edge);
    vec3 lc = lighting(baseColor);
    if (uGlow > 0.01) {
      float gf = (1.0-lf)*uGlow;
      lc += baseColor*gf*0.5 + uAccentColor*gf*0.3;
    }
    float alpha = 1.0-lf;
    if (alpha < 0.05) discard;
    fc = vec4(lc, alpha);
  } else {
    vec3 lc = lighting(baseColor);
    if (uGlow > 0.01) {
      float br = dot(lc, vec3(0.299,0.587,0.114));
      lc += lc*br*uGlow*0.4;
    }
    fc = vec4(lc, 1.0);
  }

  // Chromatic aberration
  if (uChromatic > 0.001) {
    vec2 center = vUv - 0.5;
    float dist = length(center);
    float ao = dist * uChromatic * 0.02;
    float rS = smoothstep(-0.15,0.15,vDisplacement+ao)*uIntensity;
    float bS = smoothstep(-0.15,0.15,vDisplacement-ao)*uIntensity;
    vec3 rC = mix(uPrimaryColor, uAccentColor, rS);
    vec3 bC = mix(uPrimaryColor, uAccentColor, bS);
    fc.r = mix(fc.r, rC.r*1.1, uChromatic*0.5);
    fc.b = mix(fc.b, bC.b*1.1, uChromatic*0.5);
  }

  // Film grain overlay
  if (uGrain > 0.001) {
    fc.rgb += filmGrain(vUv, uTime)*uGrain*0.15;
  }

  // Vignette
  if (uVignette > 0.001) {
    fc.rgb *= mix(1.0, vignetteEffect(vUv), uVignette);
  }

  // Depth blur simulation
  if (uBlur > 0.001) {
    float depth = length(vPosition);
    float blurF = smoothstep(1.0,5.0,depth)*uBlur;
    vec3 blurred = mix(fc.rgb, vec3(dot(fc.rgb,vec3(0.299,0.587,0.114))), blurF*0.3);
    fc.rgb = mix(fc.rgb, blurred, blurF);
  }

  gl_FragColor = fc;
}
`;

    // ====================================================================
    // RENDERER SETUP
    // ====================================================================
    const canvas = document.getElementById('scene');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x000000, 1);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, innerWidth / innerHeight, 0.1, 100);
    camera.position.set(0, 1.8, 4.5);
    camera.lookAt(0, 0, 0);

    // Large subdivided plane for the shader surface
    const geometry = new THREE.PlaneGeometry(6, 6, 180, 180);

    // Shader uniforms — surface=fluid, vibe=calm, palette=monochrome, wireframe=true, glow=0.3
    const uniforms = {
      uTime:               { value: 0 },
      uSurfaceMode:        { value: SURFACES.fluid.mode },
      uFrequency:          { value: VIBES.calm.frequency },
      uAmplitude:          { value: VIBES.calm.amplitude },
      uNoiseScale:         { value: SURFACES.fluid.noiseScale },
      uNoiseSpeed:         { value: VIBES.calm.noiseSpeed },
      uIntensity:          { value: 1.0 },
      uSpeed:              { value: 1.0 },
      uContourLines:       { value: 16 },
      uReactivityMode:     { value: 1 },    // magnetic
      uReactivityStrength: { value: 0.5 },
      uReactivityRadius:   { value: 2.0 },
      uPointer:            { value: new THREE.Vector3(0, 0, 0) },
      uShockTime:          { value: 100 },
      uAngle:              { value: 0 },
      uPrimaryColor:       { value: new THREE.Vector3(...PALETTES.monochrome.primary) },
      uAccentColor:        { value: new THREE.Vector3(...PALETTES.monochrome.accent) },
      uBackgroundColor:    { value: new THREE.Vector3(...PALETTES.monochrome.bg) },
      uWireframe:          { value: 1.0 },
      uWireframeWidth:     { value: 1.0 },
      uGrain:              { value: 0 },
      uGlow:               { value: 0.3 },
      uChromatic:          { value: 0 },
      uVignette:           { value: 0 },
      uBlur:               { value: 0 },
    };

    const material = new THREE.ShaderMaterial({
      vertexShader,
      fragmentShader,
      uniforms,
      transparent: true,
      side: THREE.DoubleSide,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      extensions: { derivatives: true },
    });

    const mesh = new THREE.Mesh(geometry, material);
    mesh.rotation.x = -Math.PI / 2;
    scene.add(mesh);

    // ====================================================================
    // RAYCASTER FOR MOUSE REACTIVITY
    // ====================================================================
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2(0, 0);
    let pointerActive = false;

    function onPointerMove(e) {
      const x = e.clientX ?? e.touches?.[0]?.clientX ?? 0;
      const y = e.clientY ?? e.touches?.[0]?.clientY ?? 0;
      pointer.x =  (x / innerWidth)  * 2 - 1;
      pointer.y = -(y / innerHeight) * 2 + 1;
      pointerActive = true;
      springs.pointerX.set(pointer.x * 2);
      springs.pointerY.set(pointer.y * 2);
    }

    canvas.addEventListener('pointermove', onPointerMove, { passive: true });
    canvas.addEventListener('touchmove', onPointerMove, { passive: true });

    // ====================================================================
    // RESIZE
    // ====================================================================
    function resize() {
      const w = innerWidth, h = innerHeight;
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', resize);
    resize();

    // ====================================================================
    // ANIMATION LOOP
    // ====================================================================
    const clock = new THREE.Clock();
    const clearColor = new THREE.Color();

    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.05);
      const elapsed = clock.getElapsedTime();

      // Tick all springs
      for (const s of Object.values(springs)) s.tick(dt);

      // Push spring values into uniforms
      uniforms.uTime.value         = elapsed;
      uniforms.uSurfaceMode.value  = springs.surfaceMode.value;
      uniforms.uFrequency.value    = springs.frequency.value;
      uniforms.uAmplitude.value    = springs.amplitude.value;
      uniforms.uNoiseScale.value   = springs.noiseScale.value;
      uniforms.uNoiseSpeed.value   = springs.noiseSpeed.value;
      uniforms.uSpeed.value        = springs.speed.value;
      uniforms.uIntensity.value    = springs.intensity.value;
      uniforms.uAngle.value        = springs.angle.value;
      uniforms.uGrain.value        = springs.grain.value;
      uniforms.uGlow.value         = springs.glow.value;
      uniforms.uChromatic.value    = springs.chromatic.value;
      uniforms.uVignette.value     = springs.vignette.value;
      uniforms.uBlur.value         = springs.blur.value;

      // Palette colors
      uniforms.uPrimaryColor.value.set(
        springs.primaryR.value, springs.primaryG.value, springs.primaryB.value
      );
      uniforms.uAccentColor.value.set(
        springs.accentR.value, springs.accentG.value, springs.accentB.value
      );
      uniforms.uBackgroundColor.value.set(
        springs.bgR.value, springs.bgG.value, springs.bgB.value
      );

      // Sync background clear with palette
      clearColor.setRGB(springs.bgR.value, springs.bgG.value, springs.bgB.value);
      renderer.setClearColor(clearColor, 1);

      // Mouse reactivity raycast
      if (pointerActive) {
        raycaster.setFromCamera(pointer, camera);
        const hits = raycaster.intersectObject(mesh);
        if (hits.length > 0) {
          uniforms.uPointer.value.copy(hits[0].point);
        }
      }

      renderer.render(scene, camera);
    }

    clock.start();
    animate();

    // ====================================================================
    // PALETTE APPLICATION + CSS ACCENT SYNC
    // ====================================================================
    function applyPalette(name) {
      currentPalette = name;
      const p = PALETTES[name];
      if (!p) return;
      springs.primaryR.set(p.primary[0]);
      springs.primaryG.set(p.primary[1]);
      springs.primaryB.set(p.primary[2]);
      springs.accentR.set(p.accent[0]);
      springs.accentG.set(p.accent[1]);
      springs.accentB.set(p.accent[2]);
      springs.bgR.set(p.bg[0]);
      springs.bgG.set(p.bg[1]);
      springs.bgB.set(p.bg[2]);
      updateCSSAccent(p);
      updateActivePaletteCard(name);
      updateActiveColorDot(name);
    }

    function updateCSSAccent(p) {
      const toI = v => Math.round(v * 255);
      const [r, g, b] = p.primary.map(toI);
      const [r2, g2, b2] = p.accent.map(toI);
      const root = document.documentElement.style;
      root.setProperty('--accent-primary', `rgb(${r},${g},${b})`);
      root.setProperty('--accent-primary-rgb', `${r},${g},${b}`);
      root.setProperty('--accent-secondary', `rgb(${r2},${g2},${b2})`);
    }

    // ====================================================================
    // BUILD PALETTE STRIP — all 13 palettes
    // ====================================================================
    const stripEl = document.getElementById('paletteStrip');
    const paletteNames = Object.keys(PALETTES);

    paletteNames.forEach(name => {
      const p = PALETTES[name];
      const card = document.createElement('div');
      card.className = 'palette-card' + (name === currentPalette ? ' active' : '');
      card.dataset.palette = name;

      card.innerHTML = `
        <div class="palette-card-name">${name}</div>
        <div class="palette-card-gradient" style="background:linear-gradient(135deg, ${p.hex[0]}, ${p.hex[1]})"></div>
        <div class="palette-card-hex">${p.hex[0]}<br>${p.hex[1]}</div>
      `;

      card.addEventListener('click', () => applyPalette(name));
      stripEl.appendChild(card);
    });

    function updateActivePaletteCard(name) {
      stripEl.querySelectorAll('.palette-card').forEach(c => {
        c.classList.toggle('active', c.dataset.palette === name);
      });
    }

    // ====================================================================
    // COLOR VARIANT DOTS (on product card)
    // ====================================================================
    const colorDots = document.querySelectorAll('.color-dot');
    colorDots.forEach(dot => {
      dot.addEventListener('click', () => {
        applyPalette(dot.dataset.palette);
      });
    });

    function updateActiveColorDot(name) {
      colorDots.forEach(d => {
        d.classList.toggle('active', d.dataset.palette === name);
      });
    }

    // ====================================================================
    // INITIAL CSS ACCENT
    // ====================================================================
    updateCSSAccent(PALETTES.monochrome);

    // ====================================================================
    // THERMAL GUARD — pause when tab hidden
    // ====================================================================
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) clock.stop(); else clock.start();
    });
  </script>
</body>
</html>
